# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lv3k0DQF38h-0hy537fwwLzcbCARtVW-
"""

# Necessary import statements:
import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf
import numpy as np
from numpy import random
from sklearn.linear_model import LogisticRegression
from scipy.stats import sem

# read default excel sheet:
df = pd.read_excel('Default.xlsx')

# output dataset to make sure it is well read:
df.head(3)

"""# Part A: 
Perform Multiple Logistic Regression (balance and income) and determine coefficients associated with income and balance
"""

# code provided by Dr. Medina:
formula = 'default ~ income + balance'
sm_model = smf.glm(formula, data=df, family=sm.families.Binomial()).fit()
print(sm_model.summary() )

print("income coef:", sm_model.params[1] )
print("balance coef:", sm_model.params[2] )

"""The estimated standard error for the coefficient associated with income is 4.99e-06.
The estimated standard error for the coefficient associated with balance is 0.

# Part B: 
Write a function that takes as input the Default data set as well as an index of the observations, and that outputs the coefficient estimates for income and balance in the multiple logistic regression mode
"""

# part B:
def partB(default, indicies):
  # create a new data set using the indices provided:
  data = default.values
  bootstraped_elems = []
  for i in range(len(data)):
    bootstraped_elems.append(data[indicies[i]])
  arr = np.array(bootstraped_elems)

  # find the coefficients of the data:
  clf = LogisticRegression(random_state=0).fit(arr[:, 3:], arr[:, 1])
  return clf.coef_[0]

"""# Part C:
Use the random.choice function to perform bootstrapping together with the function you created in (b) to estimate the standard errors of the logistic regression coefficient for income and balance.
"""

# store the seperate coefficients here:
coefficients = []

# I will bootstrap 100 times:
for i in range(100):
  # I will use random.choice to bootstrap the indices that I will use. 
  # However the requirements doc indicates to enter the default set and indices into the function form part b, 
  # so I will boot strap the actual elements using the indices I "bootstrap" here:
  size_of_df = len(df.values)
  indices = [i for i in range(size_of_df)]
  bootstrapped_indices = []
  # it must be in range of size of df b/c it the bootstrap must be the same size as original dataset according to lecture.
  for i in range(size_of_df):
    bootstrapped_indices.append(random.choice(indices))

  # convert to np array for simplicity:
  bootstrapped_indices = np.array(bootstrapped_indices)
  print(bootstrapped_indices) # proof that I am bootstrapping

  # invoke the method from part b:
  coefficients.append(partB(df, bootstrapped_indices) )

# Display the coefficients I obtained from running part B n times in part C:
np_coefficients = np.array(coefficients)
print(np_coefficients)
print('amount of sets of coeffiecents this array contains', len(np_coefficients), 'samples')

# Find the standard error of these coefficients:
standard_error_of_bootstrapped_coefficients = sem(np_coefficients)
print('standard error of bootstrapped coefficients:', standard_error_of_bootstrapped_coefficients)

"""# Part D
Comment on the estimated standard errors obtained in (a) and using your bootstrap function (obtained in (c).)

The standard errors for income and balance from part a are respectively 4.99e-06 and 0 while the standard errors in part c are 2.60785288e-04 and 7.49844152e-06. The standard errors in part a are indeed lower than in part C. However, both sets of standard errors are very small which shows quality in both models.
"""